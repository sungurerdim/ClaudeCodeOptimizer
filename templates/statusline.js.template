#!/usr/bin/env node

// Claude Code Statusline - Privacy-Focused & Feature-Rich
// Clean box design with icons, minimal path exposure

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

// ============================================================================
// CONFIGURATION
// ============================================================================
const CONFIG = {
  pathSegments: 2,      // Show last N path segments (0 = hide)
  showHostname: false,  // true = user@host, false = just user
  emojiWidth: 2,        // Terminal emoji width (1 or 2, try 1 if alignment is off)
};

// ============================================================================
// ICONS
// ============================================================================
const ICON = {
  user: 'ðŸ‘¤',
  folder: 'ðŸ“',
  model: 'ðŸ¤–',
  cc: 'ðŸ”·',
  repo: 'ðŸ”—',
  stage: 'ðŸ“¤',
  commit: 'ðŸ“¦',
  push: 'ðŸš€',
  modified: 'ðŸ“',
  new: 'âœ¨',
  deleted: 'ðŸ—‘ï¸',
  conflict: 'âš ï¸',
  stash: 'ðŸ“š',
};

// ============================================================================
// BOX DRAWING
// ============================================================================
const BOX = {
  tl: 'â”Œ', tr: 'â”', bl: 'â””', br: 'â”˜',
  h: 'â”€', v: 'â”‚', sep: 'â”‚',
};

// ============================================================================
// ANSI COLORS
// ============================================================================
const C = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[91m',
  green: '\x1b[92m',
  yellow: '\x1b[93m',
  blue: '\x1b[94m',
  magenta: '\x1b[95m',
  cyan: '\x1b[96m',
  white: '\x1b[97m',
  gray: '\x1b[90m',
};

function c(text, color) {
  return `${C[color] || ''}${text}${C.reset}`;
}

// ============================================================================
// UTILITIES
// ============================================================================
function getVisibleLength(str) {
  // Remove ANSI escape codes
  let s = str.replace(/\x1b\[[0-9;]*m/g, '');

  // Remove zero-width characters FIRST
  s = s.replace(/[\u{FE00}-\u{FE0F}\u{200B}-\u{200D}\u{2060}\u{FEFF}]/gu, '');

  // Replace emojis with configured width
  const emojiReplace = CONFIG.emojiWidth === 1 ? ' ' : '  ';
  s = s.replace(/[\u{2600}-\u{27BF}\u{2B50}-\u{2B55}\u{1F300}-\u{1F9FF}\u{1FA00}-\u{1FAFF}]/gu, emojiReplace);

  return s.length;
}

function padRight(str, len) {
  const visible = getVisibleLength(str);
  return visible >= len ? str : str + ' '.repeat(len - visible);
}

function padLeft(str, len) {
  const visible = getVisibleLength(str);
  return visible >= len ? str : ' '.repeat(len - visible) + str;
}

function execCmd(cmd) {
  try {
    return execSync(cmd, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'ignore'], timeout: 3000 }).replace(/\n$/, '');
  } catch { return null; }
}

// ============================================================================
// PATH FORMATTING
// ============================================================================
function formatPath(fullPath) {
  if (CONFIG.pathSegments === 0) return '';
  const parts = fullPath.replace(/\\/g, '/').split('/').filter(Boolean);
  if (parts.length <= CONFIG.pathSegments) return parts.join('/');
  return parts.slice(-CONFIG.pathSegments).join('/');
}

// ============================================================================
// MODEL NAME PARSING
// ============================================================================
function formatModelName(modelData) {
  return modelData?.display_name || 'Unknown';
}

// ============================================================================
// CLAUDE CODE VERSION
// ============================================================================
function getClaudeCodeVersion() {
  const version = execCmd('claude --version');
  if (version) {
    const match = version.match(/(\d+\.\d+\.\d+)/);
    if (match) return match[1];
  }
  return null;
}

// ============================================================================
// GIT INFO
// ============================================================================
function getGitInfo() {
  const branch = execCmd('git rev-parse --abbrev-ref HEAD');
  if (!branch) return null;

  const statusOutput = execCmd('git status --porcelain') || '';
  let mod = 0, add = 0, del = 0;
  let sMod = 0, sAdd = 0, sDel = 0;
  let conflict = 0, untracked = 0;

  for (const line of statusOutput.split('\n')) {
    if (!line || line.length < 2) continue;
    const idx = line.charAt(0);
    const wt = line.charAt(1);

    if (idx === 'U' || wt === 'U' || (idx === 'D' && wt === 'D') || (idx === 'A' && wt === 'A')) {
      conflict++; continue;
    }
    if (idx === '?' && wt === '?') { untracked++; continue; }

    if (wt === 'M') mod++;
    if (wt === 'D') del++;
    if (idx === 'M') sMod++;
    if (idx === 'A') sAdd++;
    if (idx === 'D') sDel++;
    if (idx === 'R') sMod++;
    if (idx === 'C') sAdd++;
  }

  add = untracked;

  // Line counts
  let unstAdd = 0, unstRem = 0, stAdd = 0, stRem = 0;

  const unstaged = execCmd('git diff --numstat');
  if (unstaged) {
    for (const line of unstaged.split('\n')) {
      const p = line.split(/\s+/);
      if (p.length >= 2) {
        const a = parseInt(p[0], 10), r = parseInt(p[1], 10);
        if (!isNaN(a)) unstAdd += a;
        if (!isNaN(r)) unstRem += r;
      }
    }
  }

  // Untracked file lines
  if (untracked > 0 && untracked <= 100) {
    const untrackedLines = execCmd('bash -c "git ls-files --others --exclude-standard | head -100 | xargs cat 2>/dev/null | wc -l"');
    if (untrackedLines) {
      const lines = parseInt(untrackedLines, 10);
      if (!isNaN(lines)) unstAdd += lines;
    }
  }

  const staged = execCmd('git diff --cached --numstat');
  if (staged) {
    for (const line of staged.split('\n')) {
      const p = line.split(/\s+/);
      if (p.length >= 2) {
        const a = parseInt(p[0], 10), r = parseInt(p[1], 10);
        if (!isNaN(a)) stAdd += a;
        if (!isNaN(r)) stRem += r;
      }
    }
  }

  // Unpushed
  let unpushed = 0;
  const tracking = execCmd('git rev-parse --abbrev-ref @{u}');
  if (tracking) {
    const cnt = execCmd('git rev-list --count @{u}..HEAD');
    unpushed = parseInt(cnt || '0', 10);
  }

  // Stash
  const stashList = execCmd('git stash list');
  const stash = stashList ? stashList.split('\n').filter(x => x.trim()).length : 0;

  // Repo name
  const gitRoot = execCmd('git rev-parse --show-toplevel');
  const repoName = gitRoot ? path.basename(gitRoot) : null;

  return {
    branch, repoName,
    mod, add, del,
    sMod, sAdd, sDel,
    unstAdd, unstRem,
    stAdd, stRem,
    unpushed, conflict, stash
  };
}

// ============================================================================
// FORMAT STATUSLINE
// ============================================================================
function formatStatusline(input, git) {
  const termWidth = process.stdout.columns || 100;
  const username = os.userInfo().username || 'user';
  const host = os.hostname() || 'host';
  const userDisplay = CONFIG.showHostname ? `${username}@${host}` : username;

  const fullPath = input.cwd || process.cwd();
  const pathDisplay = formatPath(fullPath);
  const modelDisplay = formatModelName(input.model);
  const ccVersion = getClaudeCodeVersion();

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // BUILD 4-COLUMN GRID
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Row 1: Path | User | CC | Model
  // Row 2: Repo:Branch | Conflicts | Stash | Push

  const row1 = [
    `${ICON.folder} ${c(pathDisplay, 'white')}`,
    `${ICON.user} ${c(userDisplay, 'cyan')}`,
    ccVersion ? `${ICON.cc} ${c('CC ' + ccVersion, 'yellow')}` : `${ICON.cc} ${c('CC ?', 'gray')}`,
    `${ICON.model} ${c(modelDisplay, 'magenta')}`
  ];

  let row2;
  if (git) {
    const repoText = git.repoName ? `${git.repoName}:${git.branch}` : git.branch;
    const conflictColor = git.conflict > 0 ? 'red' : 'gray';
    const stashColor = git.stash > 0 ? 'cyan' : 'gray';
    const pushColor = git.unpushed > 0 ? 'magenta' : 'gray';

    row2 = [
      `${ICON.repo} ${c(repoText, 'green')}`,
      `${ICON.conflict} ${c('Conflicts:', conflictColor)} ${c(String(git.conflict), conflictColor)}`,
      `${ICON.stash} ${c('Stash:', stashColor)} ${c(String(git.stash), stashColor)}`,
      `${ICON.push} ${c('Push:', pushColor)} ${c(String(git.unpushed), pushColor)}`
    ];
  } else {
    row2 = [
      c('Not a git repo', 'gray'),
      '',
      '',
      ''
    ];
  }

  // Calculate column widths (max of each column pair + 1 for single space padding)
  const colWidths = [];
  for (let i = 0; i < 4; i++) {
    colWidths[i] = Math.max(getVisibleLength(row1[i]), getVisibleLength(row2[i])) + 1;
  }

  // Build Stage/Commit rows (4 columns: label+lines, mod, new, del)
  let row3, row4;
  if (git) {
    const modStr = padLeft(String(git.mod), 2);
    const addStr = padLeft(String(git.add), 2);
    const delStr = padLeft(String(git.del), 2);
    const unstAddStr = padLeft(String(git.unstAdd), 4);
    const unstRemStr = padLeft(String(git.unstRem), 4);

    const sModStr = padLeft(String(git.sMod), 2);
    const sAddStr = padLeft(String(git.sAdd), 2);
    const sDelStr = padLeft(String(git.sDel), 2);
    const stAddStr = padLeft(String(git.stAdd), 4);
    const stRemStr = padLeft(String(git.stRem), 4);

    // Row 3: Stage (col1: label+lines, col2: mod, col3: new, col4: del)
    row3 = [
      `${ICON.stage} ${c('Ready to Stage ', 'white')} ${c('+' + unstAddStr, 'green')} ${c('-' + unstRemStr, 'red')}`,
      `${ICON.modified} ${c(modStr, 'yellow')}`,
      `${ICON.new} ${c(addStr, 'green')}`,
      `${ICON.deleted} ${c(delStr, 'red')}`
    ];

    // Row 4: Commit (col1: label+lines, col2: mod, col3: new, col4: del)
    row4 = [
      `${ICON.commit} ${c('Ready to Commit', 'white')} ${c('+' + stAddStr, 'green')} ${c('-' + stRemStr, 'red')}`,
      `${ICON.modified} ${c(sModStr, 'yellow')}`,
      `${ICON.new} ${c(sAddStr, 'green')}`,
      `${ICON.deleted} ${c(sDelStr, 'red')}`
    ];

    // Ensure first column can fit the labels with line counts
    const labelWidth = Math.max(getVisibleLength(row3[0]), getVisibleLength(row4[0]));
    if (labelWidth > colWidths[0] - 1) {
      colWidths[0] = labelWidth + 1;
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // BUILD LINES
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const lines = [];

  // Helper to build a row with columns
  function buildRow(cells, leftChar, sepChar, rightChar) {
    let result = c(leftChar, 'gray');
    for (let i = 0; i < cells.length; i++) {
      const content = cells[i];
      const pad = colWidths[i] - getVisibleLength(content);
      result += ` ${content}${' '.repeat(pad)}`;
      if (i < cells.length - 1) {
        result += c(sepChar, 'gray');
      }
    }
    result += c(rightChar, 'gray');
    return result;
  }

  // Helper to build a separator line
  function buildSep(leftChar, midChar, rightChar, fillChar) {
    let result = c(leftChar, 'gray');
    for (let i = 0; i < colWidths.length; i++) {
      result += c(fillChar.repeat(colWidths[i] + 1), 'gray');
      if (i < colWidths.length - 1) {
        result += c(midChar, 'gray');
      }
    }
    result += c(rightChar, 'gray');
    return result;
  }

  // Title row (same structure as buildRow, but with space/| instead of â”‚)
  lines.push(buildRow(row1, ' ', c('|', 'gray'), ' '));

  // Top border of table
  lines.push(buildSep('â”Œ', 'â”¬', 'â”', 'â”€'));

  // Row 2 (git info)
  lines.push(buildRow(row2, 'â”‚', 'â”‚', 'â”‚'));

  if (git) {
    // Middle separator (4 columns)
    lines.push(buildSep('â”œ', 'â”¼', 'â”¤', 'â”€'));

    // Stage row (4 columns)
    lines.push(buildRow(row3, 'â”‚', 'â”‚', 'â”‚'));

    // Commit row (4 columns)
    lines.push(buildRow(row4, 'â”‚', 'â”‚', 'â”‚'));

    // Bottom border (4 columns)
    lines.push(buildSep('â””', 'â”´', 'â”˜', 'â”€'));
  } else {
    // Bottom border (with columns)
    lines.push(buildSep('â””', 'â”´', 'â”˜', 'â”€'));
  }

  return lines.join('\n');
}

// ============================================================================
// MAIN
// ============================================================================
try {
  const input = JSON.parse(fs.readFileSync(0, 'utf-8'));
  const git = getGitInfo();
  console.log(formatStatusline(input, git));
} catch (error) {
  console.log(`[Statusline Error: ${error.message}]`);
}
