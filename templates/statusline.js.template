#!/usr/bin/env node

// Claude Code Statusline - High Performance
// Single-pass git status parsing, minimal file I/O

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

const CCO_STATE_DIR = path.join(__dirname, '..', '.cco', 'state');

// ANSI Color codes
const COLORS = {
  reset: '\x1b[0m',
  red: '\x1b[91m',
  green: '\x1b[92m',
  yellow: '\x1b[93m',
  blue: '\x1b[1m\x1b[94m',
  magenta: '\x1b[1m\x1b[95m',
  cyan: '\x1b[36m',
  white: '\x1b[97m',
  gray: '\x1b[90m'
};

function colorize(text, color, enabled = true) {
  if (!enabled) return text;
  return `${COLORS[color] || ''}${text}${COLORS.reset}`;
}

function padString(str, length, align = 'left') {
  const visibleLength = str.replace(/\x1b\[[0-9;]*m/g, '').length;
  const paddingNeeded = length - visibleLength;
  if (paddingNeeded <= 0) return str;
  const padding = ' '.repeat(paddingNeeded);
  return align === 'right' ? padding + str : str + padding;
}

function getVisibleLength(str) {
  return str.replace(/\x1b\[[0-9;]*m/g, '').length;
}

function truncateString(str, maxLength, suffix = '...') {
  const visibleLength = getVisibleLength(str);
  if (visibleLength <= maxLength) return str;

  let currentVisible = 0;
  let result = '';
  let inAnsiCode = false;

  for (let i = 0; i < str.length; i++) {
    if (str[i] === '\x1b') inAnsiCode = true;
    if (!inAnsiCode) {
      if (currentVisible >= maxLength - suffix.length) break;
      currentVisible++;
    }
    result += str[i];
    if (inAnsiCode && str[i] === 'm') inAnsiCode = false;
  }

  return result + suffix + COLORS.reset;
}

function execCommand(command) {
  try {
    return execSync(command, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'ignore'],
      timeout: 3000
    }).trim();
  } catch (e) {
    return null;
  }
}

// OPTIMIZED: Single git status --porcelain call + aggregated stats
function getGitInfo() {
  const branch = execCommand('git rev-parse --abbrev-ref HEAD');
  if (!branch) return null;

  // Single porcelain call for all file status
  const statusOutput = execCommand('git status --porcelain');

  let modifiedCount = 0, deletedCount = 0, untrackedCount = 0;
  let stagedModCount = 0, stagedNewCount = 0, stagedDelCount = 0;

  if (statusOutput) {
    const lines = statusOutput.split('\n');
    for (const line of lines) {
      if (!line.trim()) continue;
      const staged = line[0];
      const unstaged = line[1];

      // Unstaged changes
      if (unstaged === 'M') modifiedCount++;
      if (unstaged === 'D') deletedCount++;

      // Staged changes
      if (staged === 'M') stagedModCount++;
      if (staged === 'A') stagedNewCount++;
      if (staged === 'D') stagedDelCount++;

      // Untracked
      if (staged === '?' && unstaged === '?') untrackedCount++;
    }
  }

  // Aggregated numstat (single call for unstaged)
  let unstagedAdded = 0, unstagedRemoved = 0;
  const unstagedStats = execCommand('git diff --numstat');
  if (unstagedStats) {
    unstagedStats.split('\n').forEach(line => {
      const parts = line.split(/\s+/);
      if (parts.length >= 2) {
        unstagedAdded += parseInt(parts[0]) || 0;
        unstagedRemoved += parseInt(parts[1]) || 0;
      }
    });
  }

  // Aggregated numstat (single call for staged)
  let stagedAdded = 0, stagedRemoved = 0;
  const stagedStats = execCommand('git diff --cached --numstat');
  if (stagedStats) {
    stagedStats.split('\n').forEach(line => {
      const parts = line.split(/\s+/);
      if (parts.length >= 2) {
        stagedAdded += parseInt(parts[0]) || 0;
        stagedRemoved += parseInt(parts[1]) || 0;
      }
    });
  }

  // Unpushed commits (simplified)
  let unpushedCount = 0;
  const trackingBranch = execCommand('git rev-parse --abbrev-ref @{u}');
  if (trackingBranch) {
    const result = execCommand('git rev-list --count @{u}..HEAD');
    unpushedCount = parseInt(result || 0);
  }

  // Conflicts and stash (single calls)
  const conflictFiles = execCommand('git diff --name-only --diff-filter=U');
  const conflictCount = conflictFiles ? conflictFiles.split('\n').filter(x => x.trim()).length : 0;

  const stashList = execCommand('git stash list');
  const stashCount = stashList ? stashList.split('\n').filter(x => x.trim()).length : 0;

  // Repo name (cache-friendly)
  let repoName = null;
  const gitRoot = execCommand('git rev-parse --show-toplevel');
  if (gitRoot) repoName = path.basename(gitRoot);

  return {
    branch,
    repoName,
    // Unstaged
    modifiedFiles: modifiedCount,
    deletedFiles: deletedCount,
    untrackedFiles: untrackedCount,
    unstagedAdded,
    unstagedRemoved,
    // Staged
    stagedModifiedFiles: stagedModCount,
    stagedNewFiles: stagedNewCount,
    stagedDeletedFiles: stagedDelCount,
    stagedAdded,
    stagedRemoved,
    // Unpushed
    unpushedCommits: unpushedCount,
    // Other
    conflictCount,
    stashCount
  };
}

// OPTIMIZED: Lazy loading, single file check
function getCCOState() {
  const projectConfigFile = path.join(process.cwd(), '.cco', 'project.json');

  // Fast early exit
  if (!fs.existsSync(projectConfigFile)) {
    return { enabled: false };
  }

  try {
    const projectConfig = JSON.parse(fs.readFileSync(projectConfigFile, 'utf-8'));
    return {
      enabled: true,
      projectType: projectConfig.project_type || null,
      maturity: projectConfig.maturity || null,
      activePrinciples: (projectConfig.active_principles || []).length
    };
  } catch (e) {
    return { enabled: false };
  }
}

function formatMetricsForStatusline(inputData, git, cco) {
  const colorEnabled = true;
  const terminalWidth = process.stdout.columns || 120;
  // Only truncate if terminal is VERY narrow (< 80 cols)
  const maxLineWidth = terminalWidth < 80 ? terminalWidth - 5 : terminalWidth;

  const model = inputData.model?.display_name || 'Unknown';
  const username = os.userInfo().username || 'unknown';
  const hostname = os.hostname() || 'unknown';
  const fullPath = inputData.cwd || process.cwd();

  const lines = [];

  // Line 1: User@hostname | CC Version | Model
  const line1Parts = [
    colorize(`${username}@${hostname}`, 'cyan', colorEnabled)
  ];

  // Claude Code version (fast check)
  const claudeVersion = execCommand('claude --version');
  if (claudeVersion) {
    const versionMatch = claudeVersion.match(/(\d+\.\d+\.\d+)/);
    if (versionMatch) {
      line1Parts.push(colorize(`CC ${versionMatch[1]}`, 'yellow', colorEnabled));
    }
  }

  line1Parts.push(colorize(model, 'magenta', colorEnabled));
  lines.push(line1Parts.join(' | '));

  // Line 2: Directory | Repo:Branch
  const line2Parts = [];
  const pathParts = fullPath.split(/[\\/]/);
  const displayPath = pathParts.length > 3 && fullPath.length > 50
    ? '.../' + pathParts.slice(-2).join('/')
    : fullPath;
  line2Parts.push(colorize(displayPath, 'white', colorEnabled));

  if (git) {
    const repoDisplay = git.repoName
      ? colorize(`${git.repoName}:${git.branch}`, 'green', colorEnabled)
      : colorize(git.branch, 'green', colorEnabled);
    line2Parts.push(repoDisplay);
  }
  lines.push(line2Parts.join(' | '));

  if (!git) {
    return lines.map(line => truncateString(line, maxLineWidth)).join('\n');
  }

  // Line 3: Ready to Stage
  const modCount = git.modifiedFiles || 0;
  const newCount = git.untrackedFiles || 0;
  const delCount = git.deletedFiles || 0;

  const modCountStr = padString(colorize(`${modCount}`, 'yellow', colorEnabled), 3, 'right');
  const newCountStr = padString(colorize(`${newCount}`, 'green', colorEnabled), 3, 'right');
  const delCountStr = padString(colorize(`${delCount}`, 'red', colorEnabled), 3, 'right');

  const unstagedLine = `Ready to Stage:  ${modCountStr} mod  ${newCountStr} new  ${delCountStr} del  (${colorize(`+${git.unstagedAdded}`, 'green', colorEnabled)}/${colorize(`-${git.unstagedRemoved}`, 'red', colorEnabled)})`;

  // Add CCO status inline
  if (cco && cco.enabled) {
    const ccoParts = [];
    if (cco.projectType) ccoParts.push(colorize(cco.projectType.toUpperCase(), 'magenta', colorEnabled));
    if (cco.maturity) {
      const labels = { prototype: 'PROTO', mvp: 'MVP', active: 'DEV', production: 'PROD', maintenance: 'MAINT' };
      ccoParts.push(colorize(labels[cco.maturity] || cco.maturity.toUpperCase(), 'cyan', colorEnabled));
    }
    if (cco.activePrinciples > 0) ccoParts.push(colorize(`${cco.activePrinciples}P`, 'blue', colorEnabled));

    if (ccoParts.length > 0) {
      lines.push(unstagedLine + ' | CCO: ' + ccoParts.join(' '));
    } else {
      lines.push(unstagedLine);
    }
  } else {
    lines.push(unstagedLine);
  }

  // Line 4: Ready to Commit
  const stagedModCount = git.stagedModifiedFiles || 0;
  const stagedNewCount = git.stagedNewFiles || 0;
  const stagedDelCount = git.stagedDeletedFiles || 0;
  const stagedTotal = stagedModCount + stagedNewCount + stagedDelCount;
  const stagedColor = stagedTotal > 0 ? 'blue' : 'gray';

  const sModCountStr = padString(colorize(`${stagedModCount}`, 'yellow', colorEnabled), 3, 'right');
  const sNewCountStr = padString(colorize(`${stagedNewCount}`, 'green', colorEnabled), 3, 'right');
  const sDelCountStr = padString(colorize(`${stagedDelCount}`, 'red', colorEnabled), 3, 'right');

  const commitLabel = colorize('Ready to Commit:', stagedColor, colorEnabled);
  lines.push(`${commitLabel} ${sModCountStr} mod  ${sNewCountStr} new  ${sDelCountStr} del  (${colorize(`+${git.stagedAdded}`, 'green', colorEnabled)}/${colorize(`-${git.stagedRemoved}`, 'red', colorEnabled)})`);

  // Line 5: Ready to Push
  const unpushedColor = git.unpushedCommits > 0 ? 'magenta' : 'gray';
  const pushLabel = colorize('Ready to Push:', unpushedColor, colorEnabled);
  lines.push(`${pushLabel}     ${colorize(`${git.unpushedCommits}`, unpushedColor, colorEnabled)} commits`);

  // Line 6: Conflicts & Stashed
  const conflictColor = git.conflictCount > 0 ? 'red' : 'gray';
  const stashColor = git.stashCount > 0 ? 'cyan' : 'gray';

  lines.push(
    `${colorize('Conflicts:', conflictColor, colorEnabled)} ${colorize(`${git.conflictCount}`, conflictColor, colorEnabled)} files  |  ` +
    `${colorize('Stashed:', stashColor, colorEnabled)} ${colorize(`${git.stashCount}`, stashColor, colorEnabled)} entries`
  );

  return lines.map(line => truncateString(line, maxLineWidth)).join('\n');
}

// Main
try {
  const input = fs.readFileSync(0, 'utf-8');
  const data = JSON.parse(input);

  const git = getGitInfo();
  const cco = git ? getCCOState() : { enabled: false };

  const output = formatMetricsForStatusline(data, git, cco);
  console.log(output);
} catch (error) {
  console.log('[Statusline Error: ' + error.message + ']');
}
