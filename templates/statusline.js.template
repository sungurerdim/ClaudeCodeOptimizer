#!/usr/bin/env node

// Claude Code Statusline - Enhanced Metrics System
// Collects and displays: cost, context, git, docker, test results, system info

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const os = require('os');

const SESSIONS_DIR = path.join(__dirname, 'usage_sessions');
const BASELINE_FILE = path.join(SESSIONS_DIR, '_baseline.json');
const METRICS_FILE = path.join(SESSIONS_DIR, '_metrics.json');
const CCO_CONFIG_FILE = path.join(__dirname, 'cco.json');
const CCO_STATE_DIR = path.join(__dirname, '..', '.cco', 'state');

// ANSI Color codes (Optimized for visibility on dark backgrounds)
const COLORS = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  // Bright Foreground (90-97) with bold for maximum visibility
  black: '\x1b[90m',              // Bright black (gray)
  red: '\x1b[91m',                // Bright red
  green: '\x1b[92m',              // Bright green
  yellow: '\x1b[93m',             // Bright yellow
  blue: '\x1b[1m\x1b[94m',        // BOLD + Bright blue (extra bright!)
  magenta: '\x1b[1m\x1b[95m',     // BOLD + Bright magenta (extra bright!)
  cyan: '\x1b[36m',               // Standard cyan (darker, more subtle)
  white: '\x1b[97m',              // Bright white
  gray: '\x1b[90m'                // Gray
};

// Helper: colorize text
function colorize(text, color, enabled = true) {
  if (!enabled) return text;
  return `${COLORS[color] || ''}${text}${COLORS.reset}`;
}

// Cache for expensive operations (5 minutes TTL)
const CACHE_TTL_MS = 5 * 60 * 1000;
let metricsCache = null;
let cacheTimestamp = 0;

function execCommand(command, options = {}) {
  try {
    return execSync(command, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'ignore'],
      timeout: 5000,
      ...options
    }).trim();
  } catch (e) {
    return null;
  }
}

function getGitInfo() {
  const branch = execCommand('git rev-parse --abbrev-ref HEAD');
  if (!branch) return null;

  // Get file status with detailed breakdown (cross-platform: no wc -l)
  const modifiedFiles = execCommand('git diff --name-only --diff-filter=M');
  const modifiedCount = modifiedFiles ? modifiedFiles.split('\n').filter(x => x.trim()).length : 0;

  const deletedFiles = execCommand('git diff --name-only --diff-filter=D');
  const deletedCount = deletedFiles ? deletedFiles.split('\n').filter(x => x.trim()).length : 0;

  const untrackedFiles = execCommand('git ls-files --others --exclude-standard');
  const untrackedCount = untrackedFiles ? untrackedFiles.split('\n').filter(x => x.trim()).length : 0;

  const stagedFiles = execCommand('git diff --cached --name-only');
  const stagedCount = stagedFiles ? stagedFiles.split('\n').filter(x => x.trim()).length : 0;

  const totalChanges = modifiedCount + deletedCount + untrackedCount + stagedCount;
  const hasChanges = totalChanges > 0;

  const lastCommit = execCommand('git log -1 --format="%ar"');

  // Get repo name from remote URL or directory name
  const remoteUrl = execCommand('git config --get remote.origin.url');
  let repoName = null;
  if (remoteUrl) {
    const match = remoteUrl.match(/([^/]+?)(\.git)?$/);
    repoName = match ? match[1] : null;
  }
  if (!repoName) {
    const gitRoot = execCommand('git rev-parse --show-toplevel');
    repoName = gitRoot ? path.basename(gitRoot) : null;
  }

  // Get unpushed commits count
  // Try multiple methods to handle different scenarios:
  // 1. Remote tracking branch exists (normal case)
  // 2. No remote or no tracking branch (new repo)
  let unpushedCount = 0;

  // Check if remote tracking branch exists
  const trackingBranch = execCommand('git rev-parse --abbrev-ref @{u}');
  if (trackingBranch) {
    // Remote tracking branch exists, count unpushed commits
    const unpushedResult = execCommand('git rev-list --count @{u}..HEAD');
    unpushedCount = parseInt(unpushedResult || 0);
  } else {
    // No tracking branch, count all local commits not in any remote
    const unpushedResult = execCommand('git rev-list --count --branches --not --remotes');
    unpushedCount = parseInt(unpushedResult || 0);
  }

  // Get line stats for UNSTAGED changes (ready to stage)
  let unstagedLinesAdded = 0;
  let unstagedLinesRemoved = 0;
  const unstagedDiffStats = execCommand('git diff --numstat');
  if (unstagedDiffStats) {
    const lines = unstagedDiffStats.split('\n').filter(l => l.trim());
    for (const line of lines) {
      const parts = line.split(/\s+/);
      if (parts.length >= 2) {
        const added = parseInt(parts[0]) || 0;
        const removed = parseInt(parts[1]) || 0;
        unstagedLinesAdded += added;
        unstagedLinesRemoved += removed;
      }
    }
  }

  // Get line stats for STAGED changes (ready to commit)
  let stagedLinesAdded = 0;
  let stagedLinesRemoved = 0;
  const stagedDiffStats = execCommand('git diff --cached --numstat');
  if (stagedDiffStats) {
    const lines = stagedDiffStats.split('\n').filter(l => l.trim());
    for (const line of lines) {
      const parts = line.split(/\s+/);
      if (parts.length >= 2) {
        const added = parseInt(parts[0]) || 0;
        const removed = parseInt(parts[1]) || 0;
        stagedLinesAdded += added;
        stagedLinesRemoved += removed;
      }
    }
  }

  // Get line stats for UNPUSHED commits (ready to push)
  let unpushedLinesAdded = 0;
  let unpushedLinesRemoved = 0;
  if (trackingBranch) {
    const unpushedDiffStats = execCommand('git diff @{u}..HEAD --numstat');
    if (unpushedDiffStats) {
      const lines = unpushedDiffStats.split('\n').filter(l => l.trim());
      for (const line of lines) {
        const parts = line.split(/\s+/);
        if (parts.length >= 2) {
          const added = parseInt(parts[0]) || 0;
          const removed = parseInt(parts[1]) || 0;
          unpushedLinesAdded += added;
          unpushedLinesRemoved += removed;
        }
      }
    }
  }

  return {
    branch,
    repoName,
    hasChanges,
    changedFiles: totalChanges,
    modifiedFiles: parseInt(modifiedCount || 0),
    deletedFiles: parseInt(deletedCount || 0),
    untrackedFiles: parseInt(untrackedCount || 0),
    unstagedLinesAdded,
    unstagedLinesRemoved,
    stagedFiles: parseInt(stagedCount || 0),
    stagedLinesAdded,
    stagedLinesRemoved,
    unpushedCommits: unpushedCount,
    unpushedLinesAdded,
    unpushedLinesRemoved,
    lastCommit: lastCommit || 'unknown'
  };
}

function getDockerInfo() {
  // Check if docker is available
  const dockerVersion = execCommand('docker --version');
  if (!dockerVersion) return null;

  // Get running containers
  const runningContainers = execCommand('docker ps --format "{{.ID}}"');
  const totalContainers = execCommand('docker ps -a --format "{{.ID}}"');

  const running = runningContainers ? runningContainers.split('\n').filter(x => x).length : 0;
  const total = totalContainers ? totalContainers.split('\n').filter(x => x).length : 0;

  return {
    available: true,
    running,
    total
  };
}

function getTestInfo() {
  // Try pytest first (Python)
  let pytestResult = execCommand('pytest --collect-only -q 2>&1 | tail -1');
  if (pytestResult && pytestResult.includes('test')) {
    const match = pytestResult.match(/(\d+)\s+test/);
    if (match) {
      return {
        framework: 'pytest',
        total: parseInt(match[1]),
        passed: null, // Need to run tests to get this
        available: true
      };
    }
  }

  // Try npm test (JavaScript)
  const packageJson = path.join(process.cwd(), 'package.json');
  if (fs.existsSync(packageJson)) {
    return {
      framework: 'npm',
      available: true,
      total: null,
      passed: null
    };
  }

  return null;
}

function getSystemInfo() {
  const os = process.platform;
  const osMap = {
    'win32': 'Windows',
    'darwin': 'macOS',
    'linux': 'Linux'
  };

  // Get OS version
  let osVersion = 'unknown';
  if (os === 'win32') {
    osVersion = execCommand('wmic os get Caption /value | findstr Caption');
    if (osVersion) {
      osVersion = osVersion.replace('Caption=', '').trim();
    }
  } else if (os === 'darwin') {
    osVersion = execCommand('sw_vers -productVersion');
  } else if (os === 'linux') {
    osVersion = execCommand('lsb_release -d -s') || execCommand('cat /etc/os-release | grep PRETTY_NAME') || 'Linux';
  }

  // Get terminal info
  const termProgram = process.env.TERM_PROGRAM || process.env.TERMINAL_EMULATOR || 'unknown';
  const termVersion = process.env.TERM_PROGRAM_VERSION || '';

  return {
    os: osMap[os] || os,
    osVersion,
    terminal: termProgram,
    terminalVersion: termVersion,
    nodeVersion: process.version
  };
}

function getCCOState() {
  // Try to get CCO state from state manager
  try {
    const currentSessionFile = path.join(CCO_STATE_DIR, 'current_session.json');
    const auditResultsFile = path.join(CCO_STATE_DIR, 'audit_results.json');
    const commandHistoryFile = path.join(CCO_STATE_DIR, 'command_history.json');
    const projectConfigFile = path.join(process.cwd(), '.cco', 'project.json');

    let ccoState = {
      enabled: false,
      version: '0.1.0',
      sessionId: null,
      commandCount: 0,
      latestAudit: null,
      projectType: null,
      maturity: null,
      activePrinciples: 0,
      complianceScore: null
    };

    // Check if CCO state directory exists
    if (!fs.existsSync(CCO_STATE_DIR) && !fs.existsSync(projectConfigFile)) {
      return ccoState;
    }

    ccoState.enabled = true;

    // Get project configuration
    if (fs.existsSync(projectConfigFile)) {
      const projectConfig = JSON.parse(fs.readFileSync(projectConfigFile, 'utf-8'));
      ccoState.projectType = projectConfig.project_type || null;
      ccoState.maturity = projectConfig.maturity || null;
      ccoState.activePrinciples = (projectConfig.active_principles || []).length;
      ccoState.teamSize = projectConfig.team_size || null;
    }

    // Get current session
    if (fs.existsSync(currentSessionFile)) {
      const session = JSON.parse(fs.readFileSync(currentSessionFile, 'utf-8'));
      ccoState.sessionId = session.session_id || null;
    }

    // Get command count from command history
    if (fs.existsSync(commandHistoryFile)) {
      const history = JSON.parse(fs.readFileSync(commandHistoryFile, 'utf-8'));
      const commands = history.commands || {};
      // Count commands with at least 1 use
      ccoState.commandCount = Object.values(commands).filter(c => c.total_uses > 0).length;
    }

    // Get latest audit result with compliance score
    if (fs.existsSync(auditResultsFile)) {
      const audits = JSON.parse(fs.readFileSync(auditResultsFile, 'utf-8'));
      const auditList = audits.audits || [];
      if (auditList.length > 0) {
        const latest = auditList[auditList.length - 1];
        ccoState.latestAudit = latest;

        // Calculate compliance score from audit results
        if (latest.results) {
          const total = latest.results.length;
          const passed = latest.results.filter(r => r.status === 'pass').length;
          ccoState.complianceScore = total > 0 ? Math.round((passed / total) * 100) : null;
        }
      }
    }

    return ccoState;
  } catch (e) {
    return {
      enabled: false,
      version: '0.1.0',
      sessionId: null,
      commandCount: 0,
      latestAudit: null,
      projectType: null,
      maturity: null,
      activePrinciples: 0,
      complianceScore: null
    };
  }
}

function getProjectInfo() {
  if (!fs.existsSync(CCO_CONFIG_FILE)) {
    return {
      name: path.basename(process.cwd()),
      path: process.cwd()
    };
  }

  try {
    const ccoConfig = JSON.parse(fs.readFileSync(CCO_CONFIG_FILE, 'utf-8'));
    const project = ccoConfig.project || {};
    return {
      name: project.name || 'unknown',
      type: project.type || 'unknown',
      language: ccoConfig.detection?.primary_language || 'unknown',
      path: project.project_root || process.cwd(),
      services: project.structure?.services || []
    };
  } catch (e) {
    return {
      name: path.basename(process.cwd()),
      path: process.cwd()
    };
  }
}

function getUserConfig() {
  if (!fs.existsSync(CCO_CONFIG_FILE)) {
    return { statusline: {} };
  }

  try {
    const config = JSON.parse(fs.readFileSync(CCO_CONFIG_FILE, 'utf-8'));
    return config.preferences || { statusline: {} };
  } catch (e) {
    return { statusline: {} };
  }
}

function collectMetrics() {
  const now = Date.now();

  // Return cached metrics if still valid
  if (metricsCache && (now - cacheTimestamp) < CACHE_TTL_MS) {
    return metricsCache;
  }

  const config = getUserConfig();
  const statuslineConfig = config.statusline || {};

  const metrics = {
    timestamp: new Date().toISOString(),
    project: getProjectInfo(),
    system: getSystemInfo(),
    git: statuslineConfig.show_git_info !== false ? getGitInfo() : null,
    docker: statuslineConfig.show_docker_status !== false ? getDockerInfo() : null,
    tests: statuslineConfig.show_test_results !== false ? getTestInfo() : null,
    cco: statuslineConfig.show_cco_stats !== false ? getCCOState() : null
  };

  // Cache the result
  metricsCache = metrics;
  cacheTimestamp = now;

  // Save to file for persistence
  try {
    if (!fs.existsSync(SESSIONS_DIR)) {
      fs.mkdirSync(SESSIONS_DIR, { recursive: true });
    }
    fs.writeFileSync(METRICS_FILE, JSON.stringify(metrics, null, 2));
  } catch (e) {
    // Ignore write errors
  }

  return metrics;
}

function formatMetricsForStatusline(inputData, metrics, telemetryData) {
  const config = getUserConfig();
  const statuslineConfig = config.statusline || {};
  const colorEnabled = statuslineConfig.color_enabled !== false;

  // Parse input data from Claude Code
  const sessionId = inputData.session_id || 'unknown';
  const sessionCost = parseFloat(inputData.cost?.total_cost_usd || 0);
  const model = inputData.model?.display_name || 'Unknown';

  // Duration with 2 decimals and thousand separator
  const durationSec = inputData.cost?.total_duration_ms
    ? (inputData.cost.total_duration_ms / 1000)
    : 0;
  const durationStr = durationSec.toLocaleString('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });

  // Model context limit (define early)
  const contextTotal = 200000;

  // Calculate context usage (Try multiple sources: compact warning, stdin, telemetry, cost estimation)
  let inputTokens = inputData.cost?.total_tokens_input || 0;
  let outputTokens = inputData.cost?.total_tokens_output || 0;

  // If telemetry available, use it as fallback/supplement
  if (telemetryData) {
    inputTokens = telemetryData.tokens?.input || inputTokens;
    outputTokens = telemetryData.tokens?.output || outputTokens;
  }

  let contextUsed = (inputTokens + outputTokens) ||
                    inputData.cost?.total_tokens_used ||
                    inputData.context?.total_tokens ||
                    0;

  // Check if we have compact warning with real context percentage
  const compactContextPct = telemetryData?.compact_context_remaining_pct;
  if (compactContextPct !== null && compactContextPct !== undefined) {
    // Compact warning has REAL context data! Use it
    const remainingPct = compactContextPct / 100;
    const usedPct = 1 - remainingPct;
    contextUsed = Math.floor(contextTotal * usedPct);
  }

  // Data source indicator
  let dataSource = '';
  let isEstimated = false;
  let totalTokensUsed = 0;  // For display purposes (cumulative)

  // If we have compact warning, that's the most accurate source!
  if (compactContextPct !== null && compactContextPct !== undefined) {
    dataSource = '[compact]';
    isEstimated = false;  // This is REAL data from Claude Code
  }
  // If no token data, we can't reliably estimate context window from cost
  // Cost is cumulative but context window is capped at 200k with auto-cleanup
  else if (contextUsed === 0 && sessionCost > 0) {
    // Calculate total tokens used (cumulative, not current context)
    // Sonnet 4.5 pricing: $3/MTok input, $15/MTok output, $0.30/MTok cache read
    //
    // Real-world observation: $0.2770 for ~186k tokens = $1.49/MTok average
    // This suggests HEAVY cache read usage (80%+)
    //
    // Calibrated assumption: 80% cache read, 15% input, 5% output
    // Average: (0.80 * $0.30 + 0.15 * $3 + 0.05 * $15) = $0.24 + $0.45 + $0.75 = $1.44/MTok
    const avgCostPerToken = 1.44 / 1000000;
    totalTokensUsed = Math.floor(sessionCost / avgCostPerToken);

    // For long sessions, assume context is near capacity
    // This is rough heuristic: if session is long and costly, context is probably 70-90% full
    if (durationSec > 3600) {  // > 1 hour
      contextUsed = Math.floor(contextTotal * 0.75);  // Assume 75% full for long sessions
      dataSource = '[heuristic]';
    } else {
      // For short sessions, total might be close to current context
      contextUsed = Math.min(totalTokensUsed, contextTotal * 0.95);  // Cap at 95% to be safe
      dataSource = '[estimated]';
    }
    isEstimated = true;
  } else if (contextUsed > 0) {
    dataSource = telemetryData?.tokens?.total > 0 ? '[telemetry]' : '[live]';
  } else {
    // New session or no data yet
    if (sessionCost === 0 && durationSec < 10) {
      dataSource = '[new session]';
    } else {
      dataSource = '[no token data]';
    }
  }
  const contextRemaining = contextTotal - contextUsed;
  const contextPct = ((contextRemaining / contextTotal) * 100).toFixed(1);
  const contextColor = contextPct > 50 ? 'green' : contextPct > 20 ? 'yellow' : 'red';

  // Time estimate (based on remaining tokens)
  const estimatedMinutes = Math.floor(contextRemaining / 1000);
  const hours = Math.floor(estimatedMinutes / 60);
  const minutes = estimatedMinutes % 60;
  const timeRemaining = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;

  // Calculate grand total cost (FIX: Don't double-count current session)
  let baseline = { archivedCost: 0 };
  if (fs.existsSync(BASELINE_FILE)) {
    try {
      baseline = JSON.parse(fs.readFileSync(BASELINE_FILE, 'utf-8'));
    } catch (e) {}
  }

  let grandTotal = baseline.archivedCost || 0;
  const sessionFiles = fs.readdirSync(SESSIONS_DIR).filter(f =>
    f.endsWith('.json') &&
    f !== '_baseline.json' &&
    f !== '_metrics.json' &&
    f !== `${sessionId}.json`  // Exclude current session to avoid double-counting
  );

  for (const file of sessionFiles) {
    try {
      const filePath = path.join(SESSIONS_DIR, file);
      const session = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
      grandTotal += parseFloat(session.cost || 0);
    } catch (e) {}
  }

  // Add current session to grand total
  grandTotal += sessionCost;

  const sessionCostStr = sessionCost.toFixed(4);
  const grandTotalStr = grandTotal.toFixed(4);

  // Get user@hostname
  const username = os.userInfo().username || 'unknown';
  const hostname = os.hostname() || 'unknown';

  // Get full directory path
  const fullPath = inputData.cwd || process.cwd();

  // Get project name from CCO config
  let projectName = 'unknown';
  if (fs.existsSync(CCO_CONFIG_FILE)) {
    try {
      const ccoConfig = JSON.parse(fs.readFileSync(CCO_CONFIG_FILE, 'utf-8'));
      projectName = ccoConfig.project?.name || path.basename(fullPath);
    } catch (e) {
      projectName = path.basename(fullPath);
    }
  }

  // Build status lines based on config (OPTIMIZED UX - 3 LINE LAYOUT)
  const lines = [];

  // === LINE 1: User@hostname | CC Version | Model ===
  const line1Parts = [];

  // User@hostname (first)
  if (statuslineConfig.show_user !== false) {
    line1Parts.push(colorize(`${username}@${hostname}`, 'cyan', colorEnabled));
  }

  // Claude Code version
  const claudeVersion = execCommand('claude --version');
  if (claudeVersion && statuslineConfig.show_claude_version !== false) {
    const versionMatch = claudeVersion.match(/(\d+\.\d+\.\d+)/);
    if (versionMatch) {
      const versionDisplay = colorize(`CC ${versionMatch[1]}`, 'yellow', colorEnabled);
      line1Parts.push(versionDisplay);
    }
  }

  // Model name (bold + bright for extra visibility)
  const modelDisplay = colorize(model, 'magenta', colorEnabled);
  line1Parts.push(modelDisplay);

  lines.push(line1Parts.join(' | '));

  // === LINE 2: Directory | Repo:Branch ===
  const line2Parts = [];

  // Full directory path
  if (statuslineConfig.show_directory !== false) {
    line2Parts.push(colorize(fullPath, 'white', colorEnabled));
  }

  // Git repo:branch
  if (metrics.git && statuslineConfig.show_git_info !== false) {
    const repoDisplay = metrics.git.repoName
      ? colorize(`${metrics.git.repoName}:${metrics.git.branch}`, 'green', colorEnabled)
      : colorize(metrics.git.branch, 'green', colorEnabled);
    line2Parts.push(repoDisplay);
  }

  lines.push(line2Parts.join(' | '));

  // === LINE 3: Ready to Stage (unstaged changes) ===
  const line3Parts = [];

  if (metrics.git && statuslineConfig.show_git_info !== false) {
    const modifiedCount = metrics.git.modifiedFiles || 0;
    const newCount = metrics.git.untrackedFiles || 0;
    const deletedCount = metrics.git.deletedFiles || 0;
    const unstagedAdded = metrics.git.unstagedLinesAdded || 0;
    const unstagedRemoved = metrics.git.unstagedLinesRemoved || 0;

    // Color-coded parts: modified=yellow, new=green, deleted=red
    const modPart = colorize(`${modifiedCount} (mod)`, 'yellow', colorEnabled);
    const newPart = colorize(`${newCount} (new)`, 'green', colorEnabled);
    const delPart = colorize(`${deletedCount} (del)`, 'red', colorEnabled);
    const addDisplay = colorize(`+${unstagedAdded}`, 'green', colorEnabled);
    const removeDisplay = colorize(`-${unstagedRemoved}`, 'red', colorEnabled);

    line3Parts.push(`Ready to Stage: ${modPart} + ${newPart} + ${delPart} (${addDisplay}/${removeDisplay})`);
  }

  // Docker status (inline if enabled)
  if (metrics.docker && statuslineConfig.show_docker_status === true) {
    line3Parts.push(`Docker: ${metrics.docker.running}/${metrics.docker.total}`);
  }

  // Test results (inline if enabled)
  if (metrics.tests && statuslineConfig.show_test_results === true && metrics.tests.total) {
    const testStr = metrics.tests.passed !== null
      ? `Tests: ${metrics.tests.passed}/${metrics.tests.total}`
      : `Tests: ${metrics.tests.total}`;
    line3Parts.push(testStr);
  }

  // CCO status (if enabled and active)
  if (metrics.cco && metrics.cco.enabled) {
    const ccoParts = [];

    // Project type and maturity
    if (metrics.cco.projectType) {
      ccoParts.push(colorize(metrics.cco.projectType.toUpperCase(), 'magenta', colorEnabled));
    }

    if (metrics.cco.maturity) {
      const maturityMap = {
        'prototype': 'PROTO',
        'mvp': 'MVP',
        'active': 'DEV',
        'production': 'PROD',
        'maintenance': 'MAINT'
      };
      const label = maturityMap[metrics.cco.maturity] || metrics.cco.maturity.toUpperCase();
      ccoParts.push(colorize(label, 'cyan', colorEnabled));
    }

    // Active principles count
    if (metrics.cco.activePrinciples > 0) {
      ccoParts.push(colorize(`${metrics.cco.activePrinciples}P`, 'blue', colorEnabled));
    }

    // Compliance score (color-coded: >80=green, >60=yellow, <=60=red)
    if (metrics.cco.complianceScore !== null) {
      const scoreColor = metrics.cco.complianceScore > 80 ? 'green' :
                        metrics.cco.complianceScore > 60 ? 'yellow' : 'red';
      ccoParts.push(colorize(`${metrics.cco.complianceScore}%`, scoreColor, colorEnabled));
    }

    if (ccoParts.length > 0) {
      line3Parts.push(`CCO: ${ccoParts.join(' ')}`);
    }
  }

  lines.push(line3Parts.join(', '));

  // === LINE 4: Ready for Commit and Ready to Push ===
  const line4Parts = [];

  if (metrics.git && statuslineConfig.show_git_info !== false) {
    const stagedCount = metrics.git.stagedFiles || 0;
    const stagedAdded = metrics.git.stagedLinesAdded || 0;
    const stagedRemoved = metrics.git.stagedLinesRemoved || 0;
    const unpushedCount = metrics.git.unpushedCommits || 0;
    const unpushedAdded = metrics.git.unpushedLinesAdded || 0;
    const unpushedRemoved = metrics.git.unpushedLinesRemoved || 0;

    const stagedColor = stagedCount > 0 ? 'blue' : 'gray';
    const unpushedColor = unpushedCount > 0 ? 'magenta' : 'gray';

    // Ready to Commit (blue when >0)
    const stagedAddDisplay = colorize(`+${stagedAdded}`, 'green', colorEnabled);
    const stagedRemoveDisplay = colorize(`-${stagedRemoved}`, 'red', colorEnabled);
    line4Parts.push(colorize(`Ready to Commit: ${stagedCount} (${stagedAddDisplay}/${stagedRemoveDisplay})`, stagedColor, colorEnabled));

    // Ready to Push (magenta when >0)
    const unpushedAddDisplay = colorize(`+${unpushedAdded}`, 'green', colorEnabled);
    const unpushedRemoveDisplay = colorize(`-${unpushedRemoved}`, 'red', colorEnabled);
    line4Parts.push(colorize(`Ready to Push: ${unpushedCount} (${unpushedAddDisplay}/${unpushedRemoveDisplay})`, unpushedColor, colorEnabled));
  }

  if (line4Parts.length > 0) {
    lines.push(line4Parts.join(', '));
  }

  return lines.join('\n');
}

// Main execution
try {
  const input = fs.readFileSync(0, 'utf-8');
  const data = JSON.parse(input);

  // Collect metrics (cached for 5 minutes)
  const metrics = collectMetrics();

  // Write current telemetry data for this session
  const telemetryDir = path.join(SESSIONS_DIR, 'telemetry');
  if (!fs.existsSync(telemetryDir)) {
    fs.mkdirSync(telemetryDir, { recursive: true });
  }

  // Check for compact message in stdin to get real context percentage
  let compactContextPercent = null;
  if (data.compact_warning) {
    // Parse: "Context left until auto-compact: 7%"
    const match = data.compact_warning.match(/(\d+)%/);
    if (match) {
      compactContextPercent = parseFloat(match[1]);
    }
  }

  const currentTelemetry = {
    session_id: data.session_id,
    timestamp: new Date().toISOString(),
    tokens: {
      input: data.cost?.total_tokens_input || 0,
      output: data.cost?.total_tokens_output || 0,
      total: (data.cost?.total_tokens_input || 0) + (data.cost?.total_tokens_output || 0)
    },
    cost: data.cost?.total_cost_usd || 0,
    duration_ms: data.cost?.total_duration_ms || 0,
    lines: {
      added: data.cost?.total_lines_added || 0,
      removed: data.cost?.total_lines_removed || 0
    },
    model: data.model?.display_name || 'Unknown',
    compact_context_remaining_pct: compactContextPercent,
    raw_data: {
      has_cost_tokens_input: !!data.cost?.total_tokens_input,
      has_cost_tokens_output: !!data.cost?.total_tokens_output,
      has_cost_tokens_used: !!data.cost?.total_tokens_used,
      has_context_total_tokens: !!data.context?.total_tokens,
      cost_data_keys: Object.keys(data.cost || {}),
      context_data_keys: Object.keys(data.context || {}),
      has_compact_warning: !!data.compact_warning
    }
  };

  try {
    const telemetryFile = path.join(telemetryDir, `${data.session_id}.json`);
    fs.writeFileSync(telemetryFile, JSON.stringify(currentTelemetry, null, 2));
  } catch (e) {
    // Ignore telemetry write errors
  }

  // Try to get real-time telemetry data if available
  let telemetryData = currentTelemetry;

  // Format and output
  const output = formatMetricsForStatusline(data, metrics, telemetryData);
  console.log(output);

} catch (error) {
  // Fallback to minimal output on error
  console.log('[Statusline Error: ' + error.message + ']');
}
